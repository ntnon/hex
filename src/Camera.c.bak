#include "Camera.h"
#include "raymath.h"
#include <math.h>

//------------------------------------------------------------------------------------
// Camera Implementation
//------------------------------------------------------------------------------------

void
InitializeCamera (GameCamera *camera, int screenWidth, int screenHeight)
{
  if (!camera)
    return;

  // Initialize raylib Camera2D
  camera->camera.target = (Vector2){ 0.0f, 0.0f };
  camera->camera.offset = (Vector2){ screenWidth / 2.0f, screenHeight / 2.0f };
  camera->camera.rotation = 0.0f;
  camera->camera.zoom = 1.0f;

  // Initialize custom camera properties
  camera->target = camera->camera.target;
  camera->offset = camera->camera.offset;
  camera->zoom = camera->camera.zoom;
  camera->rotation = 0.0f;

  // Set reasonable defaults for zoom limits
  camera->minZoom = 0.1f;
  camera->maxZoom = 5.0f;

  // Initialize boundaries (will be set later based on board size)
  camera->boundaryMin = (Vector2){ -1000.0f, -1000.0f };
  camera->boundaryMax = (Vector2){ 1000.0f, 1000.0f };

  // Initialize mouse interaction state
  camera->isDragging = false;
  camera->lastMousePos = (Vector2){ 0.0f, 0.0f };
  camera->dragStartPos = (Vector2){ 0.0f, 0.0f };

  // Initialize smooth movement settings
  camera->smoothMovement = true;
  camera->smoothSpeed = 0.1f;
  camera->targetPosition = camera->target;
  camera->targetZoom = camera->zoom;

  // Initialize camera settings
  camera->zoomSpeed = 0.1f;
  camera->dragSensitivity = 1.0f;
  camera->invertDrag = false;
}

void
UpdateGameCamera (GameCamera *camera)
{
  if (!camera)
    return;

  // Handle mouse input
  Camera_HandleMouseInput (camera);

  // Apply smooth movement if enabled
  if (camera->smoothMovement)
    {
      // Smooth target position
      camera->target = Vector2Lerp (camera->target, camera->targetPosition,
                                    camera->smoothSpeed);

      // Smooth zoom
      camera->zoom
          = Lerp (camera->zoom, camera->targetZoom, camera->smoothSpeed);
    }

  // Constrain camera position to boundaries
  camera->target.x
      = Clamp (camera->target.x, camera->boundaryMin.x, camera->boundaryMax.x);
  camera->target.y
      = Clamp (camera->target.y, camera->boundaryMin.y, camera->boundaryMax.y);

  // Constrain zoom to limits
  camera->zoom = Clamp (camera->zoom, camera->minZoom, camera->maxZoom);

  // Update raylib camera
  camera->camera.target = camera->target;
  camera->camera.zoom = camera->zoom;
  camera->camera.rotation = camera->rotation;
}

void
BeginCameraMode (GameCamera *camera)
{
  if (!camera)
    return;
  BeginMode2D (camera->camera);
}

void
EndCameraMode (void)
{
  EndMode2D ();
}

void
Camera_HandleMouseInput (GameCamera *camera)
{
  if (!camera)
    return;

  Vector2 mousePos = GetMousePosition ();

  // Handle mouse wheel zoom
  float wheelMove = GetMouseWheelMove ();
  if (wheelMove != 0.0f)
    {
      float zoomAmount = wheelMove * camera->zoomSpeed;
      if (camera->smoothMovement)
        {
          camera->targetZoom += zoomAmount;
          camera->targetZoom
              = Clamp (camera->targetZoom, camera->minZoom, camera->maxZoom);
        }
      else
        {
          Camera_ZoomIn (camera, zoomAmount);
        }
    }

  // Handle mouse dragging
  if (IsMouseButtonPressed (MOUSE_BUTTON_LEFT)
      || IsMouseButtonPressed (MOUSE_BUTTON_MIDDLE))
    {
      camera->isDragging = true;
      camera->dragStartPos = mousePos;
      camera->lastMousePos = mousePos;
    }

  if (camera->isDragging)
    {
      if (IsMouseButtonDown (MOUSE_BUTTON_LEFT)
          || IsMouseButtonDown (MOUSE_BUTTON_MIDDLE))
        {
          Vector2 mouseDelta
              = Vector2Subtract (mousePos, camera->lastMousePos);

          // Invert drag direction if enabled
          if (camera->invertDrag)
            {
              mouseDelta.x = -mouseDelta.x;
              mouseDelta.y = -mouseDelta.y;
            }

          // Scale delta by drag sensitivity and zoom (so dragging feels
          // consistent at different zoom levels)
          Vector2 worldDelta = Vector2Scale (
              mouseDelta, camera->dragSensitivity / camera->zoom);

          if (camera->smoothMovement)
            {
              camera->targetPosition
                  = Vector2Subtract (camera->targetPosition, worldDelta);
            }
          else
            {
              Camera_Move (camera, Vector2Scale (worldDelta, -1.0f));
            }

          camera->lastMousePos = mousePos;
        }
      else
        {
          camera->isDragging = false;
        }
    }
}

void
Camera_SetTarget (GameCamera *camera, Vector2 target)
{
  if (!camera)
    return;

  if (camera->smoothMovement)
    {
      camera->targetPosition = target;
    }
  else
    {
      camera->target = target;
      camera->targetPosition = target;
    }
}

void
Camera_SetZoom (GameCamera *camera, float zoom)
{
  if (!camera)
    return;

  zoom = Clamp (zoom, camera->minZoom, camera->maxZoom);

  if (camera->smoothMovement)
    {
      camera->targetZoom = zoom;
    }
  else
    {
      camera->zoom = zoom;
      camera->targetZoom = zoom;
    }
}

void
Camera_ZoomIn (GameCamera *camera, float amount)
{
  if (!camera)
    return;

  if (camera->smoothMovement)
    {
      camera->targetZoom += amount;
      camera->targetZoom
          = Clamp (camera->targetZoom, camera->minZoom, camera->maxZoom);
    }
  else
    {
      camera->zoom += amount;
      camera->zoom = Clamp (camera->zoom, camera->minZoom, camera->maxZoom);
      camera->targetZoom = camera->zoom;
    }
}

void
Camera_ZoomOut (GameCamera *camera, float amount)
{
  Camera_ZoomIn (camera, -amount);
}

void
Camera_Move (GameCamera *camera, Vector2 delta)
{
  if (!camera)
    return;

  if (camera->smoothMovement)
    {
      camera->targetPosition = Vector2Add (camera->targetPosition, delta);
    }
  else
    {
      camera->target = Vector2Add (camera->target, delta);
      camera->targetPosition = camera->target;
    }
}

Vector2
Camera_ScreenToWorld (GameCamera *camera, Vector2 screenPos)
{
  if (!camera)
    return screenPos;
  return GetScreenToWorld2D (screenPos, camera->camera);
}

Vector2
Camera_WorldToScreen (GameCamera *camera, Vector2 worldPos)
{
  if (!camera)
    return worldPos;
  return GetWorldToScreen2D (worldPos, camera->camera);
}

bool
Camera_IsPointInView (GameCamera *camera, Vector2 worldPos)
{
  if (!camera)
    return false;

  Rectangle viewBounds = Camera_GetViewBounds (camera);
  return CheckCollisionPointRec (worldPos, viewBounds);
}

Rectangle
Camera_GetViewBounds (GameCamera *camera)
{
  if (!camera)
    return (Rectangle){ 0, 0, 0, 0 };

  Vector2 topLeft = Camera_ScreenToWorld (camera, (Vector2){ 0, 0 });
  Vector2 bottomRight = Camera_ScreenToWorld (
      camera, (Vector2){ camera->offset.x * 2, camera->offset.y * 2 });

  return (Rectangle){ topLeft.x, topLeft.y, bottomRight.x - topLeft.x,
                      bottomRight.y - topLeft.y };
}

void
Camera_SetBoundaries (GameCamera *camera, Vector2 min, Vector2 max)
{
  if (!camera)
    return;

  camera->boundaryMin = min;
  camera->boundaryMax = max;
}

void
Camera_SetZoomLimits (GameCamera *camera, float minZoom, float maxZoom)
{
  if (!camera)
    return;

  camera->minZoom = minZoom;
  camera->maxZoom = maxZoom;

  // Constrain current zoom to new limits
  camera->zoom = Clamp (camera->zoom, minZoom, maxZoom);
  camera->targetZoom = Clamp (camera->targetZoom, minZoom, maxZoom);
}

void
Camera_ConstrainToBoard (GameCamera *camera, float boardRadius, float hexSize)
{
  if (!camera)
    return;

  float boardSize = boardRadius * hexSize * 2.0f;
  float margin = hexSize; // Add some margin around the board

  Camera_SetBoundaries (camera,
                        (Vector2){ -boardSize - margin, -boardSize - margin },
                        (Vector2){ boardSize + margin, boardSize + margin });
}

void
Camera_EnableSmoothMovement (GameCamera *camera, float speed)
{
  if (!camera)
    return;

  camera->smoothMovement = true;
  camera->smoothSpeed = Clamp (speed, 0.01f, 1.0f);
}

void
Camera_DisableSmoothMovement (GameCamera *camera)
{
  if (!camera)
    return;

  camera->smoothMovement = false;
  camera->target = camera->targetPosition;
  camera->zoom = camera->targetZoom;
}

void
Camera_SmoothMoveToTarget (GameCamera *camera, Vector2 target)
{
  if (!camera)
    return;

  camera->targetPosition = target;
  camera->smoothMovement = true;
}

void
Camera_SmoothZoomToTarget (GameCamera *camera, float zoom)
{
  if (!camera)
    return;

  camera->targetZoom = Clamp (zoom, camera->minZoom, camera->maxZoom);
  camera->smoothMovement = true;
}

void
Camera_Reset (GameCamera *camera)
{
  if (!camera)
    return;

  Camera_SetTarget (camera, (Vector2){ 0.0f, 0.0f });
  Camera_SetZoom (camera, 1.0f);
  camera->rotation = 0.0f;
  camera->isDragging = false;
}

void
Camera_CenterOnPoint (GameCamera *camera, Vector2 point)
{
  if (!camera)
    return;

  Camera_SetTarget (camera, point);
}

void
Camera_FitToBoard (GameCamera *camera, float boardRadius, float hexSize,
                   int screenWidth, int screenHeight)
{
  if (!camera)
    return;

  // Calculate the size of the board in world units
  float boardSize = boardRadius * hexSize * 2.0f;

  // Calculate zoom to fit board in screen with some margin
  float marginFactor = 0.9f; // 90% of screen to leave some margin
  float zoomX = (screenWidth * marginFactor) / boardSize;
  float zoomY = (screenHeight * marginFactor) / boardSize;

  // Use the smaller zoom to ensure the entire board fits
  float fitZoom = fminf (zoomX, zoomY);

  // Center on the board origin and set appropriate zoom
  Camera_CenterOnPoint (camera, (Vector2){ 0.0f, 0.0f });
  Camera_SetZoom (camera, fitZoom);
}
