#include "HexBoard.h"
#include "raymath.h"
#include <math.h>
#include <stdio.h>
#include <stdlib.h>

#ifndef MAX
#define MAX(a, b) ((a) > (b) ? (a) : (b))
#endif

#ifndef MIN
#define MIN(a, b) ((a) < (b) ? (a) : (b))
#endif

#ifndef PI
#define PI 3.14159265358979323846
#endif

#ifndef DEG2RAD
#define DEG2RAD (PI / 180.0f)
#endif

//------------------------------------------------------------------------------------
// Hex Drawing Functions
//------------------------------------------------------------------------------------

void
DrawHexagon (Vector2 center, float radius, Color fillColor, Color outlineColor)
{
  const int sides = 6;

  // Draw filled hex
  DrawPoly (center, sides, radius, 0, fillColor);

  // Draw hex outline
  DrawPolyLines (center, sides, radius, 0, outlineColor);
}

void
DrawHexagonFill (Vector2 center, float radius, Color fillColor)
{
  // Draw only filled hex without outline - edges will be drawn separately
  DrawPoly (center, 6, radius, 0, fillColor);
}

void
DrawTileDots (Vector2 center, float hexRadius, int dotCount, Color dotColor)
{
  float dotRadius = hexRadius * 0.12f;

  if (dotCount == 1)
    {
      // Single dot in center
      DrawCircleV (center, dotRadius, dotColor);
    }
  else if (dotCount == 2)
    {
      // Two dots horizontally
      float spacing = hexRadius * 0.25f;
      DrawCircleV ((Vector2){ center.x - spacing, center.y }, dotRadius,
                   dotColor);
      DrawCircleV ((Vector2){ center.x + spacing, center.y }, dotRadius,
                   dotColor);
    }
  else if (dotCount == 3)
    {
      // Three dots in triangle formation
      float spacing = hexRadius * 0.2f;
      DrawCircleV ((Vector2){ center.x, center.y - spacing }, dotRadius,
                   dotColor);
      DrawCircleV ((Vector2){ center.x - spacing, center.y + spacing },
                   dotRadius, dotColor);
      DrawCircleV ((Vector2){ center.x + spacing, center.y + spacing },
                   dotRadius, dotColor);
    }
}

//------------------------------------------------------------------------------------
// Hex Coordinate and Math Functions
//------------------------------------------------------------------------------------

void
PixelToAxial (Vector2 pos, float hexSize, int *q, int *r)
{
  float qf = (2.0f / 3.0f * pos.x) / hexSize;
  float rf = (-1.0f / 3.0f * pos.x + sqrtf (3.0f) / 3.0f * pos.y) / hexSize;

  int rq = roundf (qf);
  int rr = roundf (rf);
  int rs = roundf (-qf - rf);

  float q_diff = fabsf (rq - qf);
  float r_diff = fabsf (rr - rf);
  float s_diff = fabsf (rs + qf + rf);

  if (q_diff > r_diff && q_diff > s_diff)
    rq = -rr - rs;
  else if (r_diff > s_diff)
    rr = -rq - rs;

  *q = rq;
  *r = rr;
}

int
HexDistance (int q1, int r1, int q2, int r2)
{
  int dq = q1 - q2;
  int dr = r1 - r2;
  return (abs (dq) + abs (dr) + abs (dq + dr)) / 2;
}

HexTile *
FindHoveredTile (HexBoard *board, int mouseQ, int mouseR)
{
  for (int i = 0; i < board->tileCount; i++)
    {
      if (board->tiles[i].q == mouseQ && board->tiles[i].r == mouseR)
        {
          return &board->tiles[i];
        }
    }
  return NULL;
}

//------------------------------------------------------------------------------------
// Tile State Management Functions
//------------------------------------------------------------------------------------

void
SetTileState (HexTile *tile, TileState state)
{
  SetTileStateWithSource (tile, state, SOURCE_NATURAL);
}

void
SetTileStateWithSource (HexTile *tile, TileState state, TileSource source)
{
  tile->state = state;
  tile->source = source;
  UpdateTileAppearance (tile);
}

Color
GetTileStateColor (TileState state)
{
  switch (state)
    {
    case TILE_EMPTY:
      return LIGHTGRAY;
    case TILE_WORLD_SPAWN:
      return GOLD;
    case TILE_STRUCTURE_HOUSE:
      return BROWN;
    case TILE_STRUCTURE_TOWER:
      return DARKGRAY;
    case TILE_STRUCTURE_FARM:
      return GREEN;
    case TILE_RESOURCE_WOOD:
      return (Color){ 139, 69, 19, 255 }; // Saddle brown
    case TILE_RESOURCE_STONE:
      return GRAY;
    case TILE_RESOURCE_WATER:
      return BLUE;
    case TILE_BLOCKED:
      return BLACK;
    case TILE_SELECTED:
      return YELLOW;
    case TILE_BASE:
      return GREEN;
    case TILE_SPECIAL_MAGENTA:
      return (Color){ 255, 0, 255, 255 }; // Bright magenta
    case TILE_SPECIAL_CYAN:
      return (Color){ 0, 255, 255, 255 }; // Bright cyan
    case TILE_SPECIAL_YELLOW:
      return (Color){ 255, 255, 0, 255 }; // Bright yellow
    case TILE_PLACED:
      return LIGHTGRAY; // Will be overridden by piece color
    case TILE_DESTROYER:
      return (Color){ 128, 0, 128, 255 }; // Dark purple for destroyer
    default:
      return LIGHTGRAY;
    }
}

const char *
GetTileStateName (TileState state)
{
  switch (state)
    {
    case TILE_EMPTY:
      return "Empty";
    case TILE_WORLD_SPAWN:
      return "Spawn";
    case TILE_STRUCTURE_HOUSE:
      return "House";
    case TILE_STRUCTURE_TOWER:
      return "Tower";
    case TILE_STRUCTURE_FARM:
      return "Farm";
    case TILE_RESOURCE_WOOD:
      return "Wood";
    case TILE_RESOURCE_STONE:
      return "Stone";
    case TILE_RESOURCE_WATER:
      return "Water";
    case TILE_BLOCKED:
      return "Blocked";
    case TILE_SELECTED:
      return "Selected";
    case TILE_BASE:
      return "Base";
    case TILE_SPECIAL_MAGENTA:
      return "Magenta";
    case TILE_SPECIAL_CYAN:
      return "Cyan";
    case TILE_SPECIAL_YELLOW:
      return "Yellow";
    case TILE_PLACED:
      return "Placed";
    case TILE_DESTROYER:
      return "Destroyer";
    default:
      return "Unknown";
    }
}

void
UpdateTileAppearance (HexTile *tile)
{
  tile->color = GetTileStateColor (tile->state);
}

//------------------------------------------------------------------------------------
// Render Info Derivation Functions
//------------------------------------------------------------------------------------

TileColor
GetTileColor (HexTile *tile)
{
  // All colored tiles (special or placed) use stored tileColor
  switch (tile->state)
    {
    case TILE_SPECIAL_MAGENTA:
    case TILE_SPECIAL_CYAN:
    case TILE_SPECIAL_YELLOW:
    case TILE_PLACED:
      return tile->tileColor;
    default:
      // Empty/base tiles don't have meaningful colors for accessibility
      return TILE_COLOR_MAGENTA; // Default fallback
    }
}

int
GetTileDotCount (HexTile *tile)
{
  // Only show dots for colored tiles (special or placed)
  switch (tile->state)
    {
    case TILE_SPECIAL_MAGENTA:
    case TILE_SPECIAL_CYAN:
    case TILE_SPECIAL_YELLOW:
    case TILE_PLACED:
      return tile->dotCount;
    default:
      return 0; // No dots for empty, base, or other system tiles
    }
}

Color
GetTileRenderColor (HexTile *tile)
{
  // For colored tiles (special or placed), use stored color
  switch (tile->state)
    {
    case TILE_SPECIAL_MAGENTA:
    case TILE_SPECIAL_CYAN:
    case TILE_SPECIAL_YELLOW:
    case TILE_PLACED:
      return tile->color;
    default:
      // For other system tiles, derive from state
      return GetTileStateColor (tile->state);
    }
}

//------------------------------------------------------------------------------------
// Tile Filtering Functions
//------------------------------------------------------------------------------------

bool
IsEmptyTile (HexTile *tile)
{
  return tile->state == TILE_EMPTY;
}

bool
IsWalkableTile (HexTile *tile)
{
  return true; // All tiles are walkable now
}

//------------------------------------------------------------------------------------
// Core HexBoard Functions
//------------------------------------------------------------------------------------

void
HexBoard_Init (HexBoard *board, int radius, float size, Vector2 offset)
{
  printf ("HexBoard_Init called with radius=%d, size=%.1f\n", radius, size);

  if (!board)
    {
      printf ("Error: board is NULL\n");
      return;
    }

  printf ("Board pointer is valid, continuing...\n");

  // Initialize basic board properties
  board->hexSize = size;
  board->origin = offset;
  board->tileCount = 0;
  board->edgeCount = 0;
  board->poolCount = 0;

  // Calculate maximum tiles needed
  int maxTiles = (radius * 2 + 1) * (radius * 2 + 1);
  printf ("Calculated maxTiles: %d\n", maxTiles);

  // Allocate memory for tiles
  printf ("Allocating memory for %d tiles...\n", maxTiles);
  board->tiles = malloc (sizeof (HexTile) * maxTiles);
  if (!board->tiles)
    {
      printf ("Error: malloc failed for tiles\n");
      board->tileCount = 0;
      return;
    }

  printf ("Memory allocation successful\n");

  // Create tiles with minimal initialization
  for (int q = -radius; q <= radius; q++)
    {
      int r1 = MAX (-radius, -q - radius);
      int r2 = MIN (radius, -q + radius);

      for (int r = r1; r <= r2; r++)
        {
          HexTile tile = { 0 };
          tile.q = q;
          tile.r = r;

          // Convert axial coordinates to pixel position
          tile.center.x = size * (3.0f / 2.0f * q) + offset.x;
          tile.center.y
              = size * (sqrtf (3.0f) / 2.0f * q + sqrtf (3.0f) * r) + offset.y;

          // Minimal tile setup
          tile.state = TILE_EMPTY;
          tile.source = SOURCE_NATURAL;
          tile.tileColor = TILE_COLOR_MAGENTA;
          tile.dotCount = 0;
          tile.pieceId = 0;
          tile.poolId = -1;
          tile.isReachableFromSpawn = false;
          tile.color = LIGHTGRAY;

          board->tiles[board->tileCount++] = tile;
        }
    }

  // Initialize edge system (minimal)
  for (int i = 0; i < MAX_HEX_EDGES; i++)
    {
      board->edges[i].isActive = false;
      board->edges[i].tileIndex1 = -1;
      board->edges[i].tileIndex2 = -1;
      board->edges[i].shouldDraw = false;
      board->edges[i].edgeStrength = 1.0f;
      board->edges[i].edgeType = EDGE_GRID;
    }

  // Initialize pool system (minimal)
  for (int i = 0; i < MAX_POOLS; i++)
    {
      board->pools[i].isActive = false;
      board->pools[i].tileCount = 0;
      board->pools[i].primaryColor = TILE_COLOR_MAGENTA;
      board->pools[i].isMixedColor = false;
      board->pools[i].bridgeTileCount = 0;

      for (int j = 0; j < TILE_COLOR_COUNT; j++)
        {
          board->pools[i].colorCounts[j] = 0;
        }
    }

  // Skip edge initialization and complex setup for now
  // This will be added back gradually once basic system works

  printf ("HexBoard_Init completed successfully with %d tiles\n",
          board->tileCount);
}

void
HexBoard_Draw (HexBoard *board, void *gameState)
{
  if (!board || !gameState)
    return;

  // Cast void* back to GameState* - we know this is safe in our context
  // GameState* gs = (GameState*)gameState;

  // --- First pass: draw all tiles (hexagons, dots, icons, etc.) ---
  for (int i = 0; i < board->tileCount; i++)
    {
      HexTile *tile = &board->tiles[i];

      // Determine if this tile should be highlighted
      bool isHighlighted = false; // TODO: implement highlighting

      // Draw the hex with highlighting if needed
      Color hexColor = tile->color;

      if (isHighlighted)
        {
          // Brighten the color for highlighted pieces
          hexColor = (Color){ MIN (255, hexColor.r + 50),
                              MIN (255, hexColor.g + 50),
                              MIN (255, hexColor.b + 50), 255 };
        }

      // Draw only the hexagon fill - edges will be drawn separately
      DrawHexagonFill (tile->center, board->hexSize, hexColor);

      // Draw base tile effects (subtle glow)
      if (tile->state == TILE_BASE)
        {
          // Draw subtle pulsing glow for base tiles
          float time = GetTime ();
          float pulseAlpha = 0.1f + 0.05f * sinf (time * 2.0f);
          Color baseGlow
              = (Color){ 0, 255, 0, (unsigned char)(255 * pulseAlpha) };

          // Draw subtle glow circle behind the hex
          DrawCircleV (tile->center, board->hexSize * 1.1f, baseGlow);
        }

      // Draw dots for accessibility using derived dot count
      int dotCount = GetTileDotCount (tile);
      if (dotCount > 0)
        {
          Color dotColor = BLACK;

          // Use white dots on special tiles for better contrast
          if (tile->state == TILE_SPECIAL_MAGENTA
              || tile->state == TILE_SPECIAL_CYAN
              || tile->state == TILE_SPECIAL_YELLOW)
            {
              dotColor = WHITE;
            }

          DrawTileDots (tile->center, board->hexSize, dotCount, dotColor);
        }

      // Draw special icons on special tiles
      if (tile->state == TILE_SPECIAL_MAGENTA
          || tile->state == TILE_SPECIAL_CYAN
          || tile->state == TILE_SPECIAL_YELLOW)
        {
          // Draw a simple star icon
          float iconSize = board->hexSize * 0.3f;
          Vector2 iconPos
              = { tile->center.x, tile->center.y - board->hexSize * 0.4f };

          // Draw star with 5 points
          DrawPoly (iconPos, 5, iconSize * 0.6f, 0, GOLD);
          DrawPolyLines (iconPos, 5, iconSize * 0.6f, 0, DARKBROWN);
        }
    }

  // --- Second pass: draw all special tile effects (glow, sparks) on top ---
  for (int i = 0; i < board->tileCount; i++)
    {
      HexTile *tile = &board->tiles[i];
      if (tile->state == TILE_SPECIAL_MAGENTA
          || tile->state == TILE_SPECIAL_CYAN
          || tile->state == TILE_SPECIAL_YELLOW)
        {
          // Draw pulsing glow effect for special tiles
          float time = GetTime ();
          float pulseAlpha = 0.3f + 0.2f * sinf (time * 3.0f);
          Color glowColor = tile->color;
          glowColor.a = (unsigned char)(255 * pulseAlpha);

          // Draw larger glow circle behind the hex
          DrawCircleV (tile->center, board->hexSize * 1.2f, glowColor);

          // Draw sparkling border
          for (int spark = 0; spark < 6; spark++)
            {
              float angle = (time + spark * 60.0f) * DEG2RAD;
              Vector2 sparkPos
                  = { tile->center.x + cosf (angle) * board->hexSize * 0.9f,
                      tile->center.y + sinf (angle) * board->hexSize * 0.9f };
              DrawCircleV (sparkPos, 2.0f, WHITE);
            }
        }
    }

  // --- Third pass: draw grid edges (thin, always visible) ---
  HexBoard_DrawGridEdges (board, gameState);

  // --- Fourth pass: draw thick pool borders ---
  HexBoard_DrawPoolBorders (board, gameState);
}

void
HexBoard_Free (HexBoard *board)
{
  if (board && board->tiles)
    {
      free (board->tiles);
      board->tiles = NULL;
      board->tileCount = 0;
    }
}

//------------------------------------------------------------------------------------
// Edge Management Functions
//------------------------------------------------------------------------------------

void
HexBoard_InitializeEdges (HexBoard *board)
{
  if (!board)
    return;

  board->edgeCount = 0;

  // Create edges by examining each tile's 6 sides and storing exact vertex
  // positions
  for (int i = 0; i < board->tileCount; i++)
    {
      HexTile *tile1 = &board->tiles[i];
      float hexSize = board->hexSize;

      // Calculate the 6 vertices of this hexagon
      Vector2 vertices[6];
      for (int v = 0; v < 6; v++)
        {
          float angle = (v * 60.0f - 30.0f) * DEG2RAD;
          vertices[v].x = tile1->center.x + hexSize * cosf (angle);
          vertices[v].y = tile1->center.y + hexSize * sinf (angle);
        }

      // Create edges for each side of the hexagon
      for (int side = 0; side < 6; side++)
        {
          if (board->edgeCount >= MAX_HEX_EDGES)
            break;

          // Find the neighbor in this direction
          int neighbor_q[6] = { 1, 1, 0, -1, -1, 0 };
          int neighbor_r[6] = { 0, -1, -1, 0, 1, 1 };

          int neighborQ = tile1->q + neighbor_q[side];
          int neighborR = tile1->r + neighbor_r[side];

          int neighborIndex = -1;
          for (int j = 0; j < board->tileCount; j++)
            {
              if (board->tiles[j].q == neighborQ
                  && board->tiles[j].r == neighborR)
                {
                  neighborIndex = j;
                  break;
                }
            }

          // Only create edge if this is the "lower" tile index (avoid
          // duplicates)
          bool shouldCreateEdge = (neighborIndex == -1) || (i < neighborIndex);

          if (shouldCreateEdge)
            {
              HexEdge *edge = &board->edges[board->edgeCount];
              edge->isActive = true;
              edge->tileIndex1 = i;
              edge->tileIndex2 = neighborIndex;
              edge->shouldDraw = true;
              edge->edgeStrength = 1.0f;
              edge->edgeType = EDGE_GRID;

              // Store exact vertex positions for this edge
              int nextVertex = (side + 1) % 6;
              edge->startPoint = vertices[side];
              edge->endPoint = vertices[nextVertex];

              board->edgeCount++;
            }
        }
    }
}

void
HexBoard_UpdateEdgeStates (HexBoard *board)
{
  if (!board)
    return;

  for (int i = 0; i < board->edgeCount; i++)
    {
      HexEdge *edge = &board->edges[i];
      if (!edge->isActive)
        continue;

      // All edges are drawn as grid edges by default
      edge->shouldDraw = true;
      edge->edgeType = EDGE_GRID;

      // Check if this edge should be marked as a pool edge
      if (edge->tileIndex1 >= 0)
        {
          HexTile *tile1 = &board->tiles[edge->tileIndex1];

          if (edge->tileIndex2 < 0)
            {
              // Boundary edge - mark as pool edge if tile1 is in a pool
              if (tile1->poolId >= 0 && tile1->state != TILE_EMPTY)
                {
                  edge->edgeType = EDGE_POOL;
                }
            }
          else
            {
              // Edge between two tiles
              HexTile *tile2 = &board->tiles[edge->tileIndex2];
              bool tile1InPool
                  = (tile1->poolId >= 0 && tile1->state != TILE_EMPTY);
              bool tile2InPool
                  = (tile2->poolId >= 0 && tile2->state != TILE_EMPTY);

              if (tile1InPool && tile2InPool)
                {
                  // Both in pools - mark as pool edge if different pools
                  if (tile1->poolId != tile2->poolId)
                    {
                      edge->edgeType = EDGE_POOL;
                    }
                }
              else if (tile1InPool || tile2InPool)
                {
                  // One in pool, one not - mark as pool edge
                  edge->edgeType = EDGE_POOL;
                }
            }
        }
    }
}

void
HexBoard_DrawGridEdges (HexBoard *board, void *gameState)
{
  if (!board)
    return;

  // Draw all edges as thin grid lines using stored vertex positions
  for (int i = 0; i < board->edgeCount; i++)
    {
      HexEdge *edge = &board->edges[i];
      if (edge->isActive && edge->shouldDraw)
        {
          DrawLineEx (edge->startPoint, edge->endPoint, 1.5f, DARKGRAY);
        }
    }
}

void
HexBoard_DrawPoolBorders (HexBoard *board, void *gameState)
{
  if (!board)
    return;

  // TODO: Get game state and check pool visualization settings
  // For now, just draw pool edges when they exist

  // Draw thick borders for edges that separate different pools
  for (int i = 0; i < board->edgeCount; i++)
    {
      HexEdge *edge = &board->edges[i];
      if (!edge->isActive || !edge->shouldDraw || edge->edgeType != EDGE_POOL)
        continue;

      // Draw thick border
      DrawLineEx (edge->startPoint, edge->endPoint, 4.0f, BLACK);
    }
}

void
HexBoard_CalculateEdgeEndpoints (HexBoard *board, int edgeIndex)
{
  // This function is no longer needed - edge endpoints are calculated
  // directly during edge creation with proper vertex positions
  (void)board;
  (void)edgeIndex;
}

//------------------------------------------------------------------------------------
// Pool Management Functions (Basic Implementation)
//------------------------------------------------------------------------------------

void
HexBoard_FindAllPools (HexBoard *board)
{
  // TODO: Implement pool finding algorithm
  (void)board;
}

void
HexBoard_CalculateReachability (HexBoard *board)
{
  // TODO: Implement reachability calculation
  (void)board;
}

int
HexBoard_CreatePool (HexBoard *board, TileColor color, int initialLifeCounter)
{
  // TODO: Implement pool creation
  (void)board;
  (void)color;
  (void)initialLifeCounter;
  return -1;
}

void
HexBoard_DestroyPool (HexBoard *board, int poolId)
{
  // TODO: Implement pool destruction
  (void)board;
  (void)poolId;
}

void
HexBoard_AddTileToPool (HexBoard *board, int tileIndex, int poolId)
{
  // TODO: Implement adding tile to pool
  (void)board;
  (void)tileIndex;
  (void)poolId;
}

void
HexBoard_RemoveTileFromPool (HexBoard *board, int tileIndex)
{
  // TODO: Implement removing tile from pool
  (void)board;
  (void)tileIndex;
}

void
HexBoard_MergePools (HexBoard *board, int keepPoolId, int removePoolId)
{
  // TODO: Implement pool merging
  (void)board;
  (void)keepPoolId;
  (void)removePoolId;
}

void
HexBoard_UpdatePoolCenter (HexBoard *board, int poolId)
{
  // TODO: Implement pool center update
  (void)board;
  (void)poolId;
}

bool
HexBoard_IsPoolActive (HexBoard *board, int poolId)
{
  // TODO: Implement pool active check
  (void)board;
  (void)poolId;
  return false;
}

//------------------------------------------------------------------------------------
// Piece ID Functions
//------------------------------------------------------------------------------------

int
GetPieceHexes (HexBoard *board, int pieceId, HexTile *outTiles[], int maxTiles)
{
  int count = 0;

  for (int i = 0; i < board->tileCount && count < maxTiles; i++)
    {
      if (board->tiles[i].pieceId == pieceId && pieceId != 0)
        {
          outTiles[count] = &board->tiles[i];
          count++;
        }
    }

  return count;
}

void
HighlightPiece (HexBoard *board, int pieceId)
{
  // Reset all tiles to their default appearance first
  for (int i = 0; i < board->tileCount; i++)
    {
      UpdateTileAppearance (&board->tiles[i]);
    }

  // Highlight all tiles belonging to the specified piece
  if (pieceId != 0)
    {
      for (int i = 0; i < board->tileCount; i++)
        {
          if (board->tiles[i].pieceId == pieceId)
            {
              // Add a bright border or overlay to highlight the piece
              board->tiles[i].color = (Color){
                board->tiles[i].color.r, board->tiles[i].color.g,
                board->tiles[i].color.b,
                200 // Semi-transparent overlay
              };
            }
        }
    }
}

//------------------------------------------------------------------------------------
// Comparison Function
//------------------------------------------------------------------------------------

int
compareTileDistance (const void *a, const void *b)
{
  TileDistance *tileA = (TileDistance *)a;
  TileDistance *tileB = (TileDistance *)b;

  if (tileA->distance < tileB->distance)
    return -1;
  if (tileA->distance > tileB->distance)
    return 1;
  return 0;
}
