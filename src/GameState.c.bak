#include "GameState.h"
#include "raylib.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

//------------------------------------------------------------------------------------
// GameState Implementation
//------------------------------------------------------------------------------------

void
GameState_Init (GameState *state)
{
  if (!state)
    return;

  // Initialize screen management
  state->currentScreen = SCREEN_GAMEPLAY;
  state->previousScreen = SCREEN_MENU;

  // Initialize game state flags
  state->isPaused = false;
  state->showTileInfo = true;
  state->showDebugInfo = false;

  // Initialize mouse and input state
  state->mouseWorldPos = (Vector2){ 0.0f, 0.0f };
  state->mouseScreenPos = (Vector2){ 0.0f, 0.0f };
  state->isMousePressed = false;
  state->isMouseReleased = false;

  // Initialize selected tile information
  state->selectedTile = NULL;
  state->selectedTileCount = 0;

  // Initialize highlighted piece system
  state->highlightedPieceId = -1;

  // Initialize pool visualization settings
  state->showPoolVisualization = true;
  state->showPoolBorders = true;
  state->poolBorderThickness = 4.0f;
  state->showPoolInfoCard = true;
  state->poolBorderColor = BLACK;
  state->poolGlintIntensity = 0.5f;

  // Initialize UI settings
  state->backgroundColor = RAYWHITE;
  state->primaryTextColor = BLACK;
  state->secondaryTextColor = DARKGRAY;
  state->infoCardPadding = 10.0f;
  state->infoCardBorderRadius = 0.1f;

  // Initialize performance and debug
  state->frameTime = 0.0f;
  state->fps = 60;
}

void
GameState_Update (GameState *state)
{
  if (!state)
    return;

  // Update performance metrics
  state->frameTime = GetFrameTime ();
  state->fps = GetFPS ();

  // Update mouse input state
  GameState_UpdateMouseInput (state);

  // Handle general input
  GameState_HandleInput (state);
}

void
GameState_Free (GameState *state)
{
  if (!state)
    return;

  // Clear selected tile
  state->selectedTile = NULL;
  state->selectedTileCount = 0;

  // Reset highlighted piece
  state->highlightedPieceId = -1;
}

void
GameState_HandleInput (GameState *state)
{
  if (!state)
    return;

  // Handle screen switching
  if (IsKeyPressed (KEY_ESCAPE))
    {
      if (state->currentScreen == SCREEN_GAMEPLAY)
        {
          GameState_SwitchScreen (state, SCREEN_MENU);
        }
      else if (state->currentScreen == SCREEN_MENU)
        {
          GameState_SwitchScreen (state, SCREEN_GAMEPLAY);
        }
    }

  // Handle debug toggles
  if (IsKeyPressed (KEY_F3))
    {
      state->showDebugInfo = !state->showDebugInfo;
    }

  if (IsKeyPressed (KEY_F4))
    {
      state->showTileInfo = !state->showTileInfo;
    }

  // Handle pool visualization toggles
  if (IsKeyPressed (KEY_P))
    {
      GameState_TogglePoolVisualization (state);
    }

  if (IsKeyPressed (KEY_B))
    {
      GameState_TogglePoolBorders (state);
    }

  if (IsKeyPressed (KEY_I))
    {
      GameState_TogglePoolInfoCard (state);
    }

  // Handle pool border thickness adjustment
  if (IsKeyDown (KEY_LEFT_BRACKET) && state->poolBorderThickness > 1.0f)
    {
      state->poolBorderThickness -= 0.5f;
    }
  if (IsKeyDown (KEY_RIGHT_BRACKET) && state->poolBorderThickness < 10.0f)
    {
      state->poolBorderThickness += 0.5f;
    }
}

void
GameState_UpdateMouseInput (GameState *state)
{
  if (!state)
    return;

  // Update mouse positions
  state->mouseScreenPos = GetMousePosition ();

  // Update mouse button states
  state->isMousePressed = IsMouseButtonPressed (MOUSE_BUTTON_LEFT);
  state->isMouseReleased = IsMouseButtonReleased (MOUSE_BUTTON_LEFT);
}

void
GameState_SwitchScreen (GameState *state, ScreenState newScreen)
{
  if (!state)
    return;

  state->previousScreen = state->currentScreen;
  state->currentScreen = newScreen;
}

void
GameState_SetSelectedTile (GameState *state, void *tile)
{
  if (!state)
    return;

  state->selectedTile = tile;
  state->selectedTileCount = (tile != NULL) ? 1 : 0;
}

void
GameState_ClearSelection (GameState *state)
{
  if (!state)
    return;

  state->selectedTile = NULL;
  state->selectedTileCount = 0;
  state->highlightedPieceId = -1;
}

void
GameState_TogglePoolVisualization (GameState *state)
{
  if (!state)
    return;

  state->showPoolVisualization = !state->showPoolVisualization;

  // If turning off pool visualization, also turn off related features
  if (!state->showPoolVisualization)
    {
      state->showPoolBorders = false;
      state->showPoolInfoCard = false;
    }
}

void
GameState_TogglePoolBorders (GameState *state)
{
  if (!state)
    return;

  state->showPoolBorders = !state->showPoolBorders;

  // If turning on pool borders, make sure pool visualization is also on
  if (state->showPoolBorders)
    {
      state->showPoolVisualization = true;
    }
}

void
GameState_TogglePoolInfoCard (GameState *state)
{
  if (!state)
    return;

  state->showPoolInfoCard = !state->showPoolInfoCard;

  // If turning on pool info card, make sure pool visualization is also on
  if (state->showPoolInfoCard)
    {
      state->showPoolVisualization = true;
    }
}

TileColorInfo
GameState_GetTileColorInfo (TileColor color)
{
  static const TileColorInfo colorInfos[TILE_COLOR_COUNT] = {
    { (Color){ 255, 0, 255, 255 }, 1, "Magenta" }, // TILE_COLOR_MAGENTA
    { (Color){ 0, 255, 255, 255 }, 2, "Cyan" },    // TILE_COLOR_CYAN
    { (Color){ 255, 255, 0, 255 }, 3, "Yellow" },  // TILE_COLOR_YELLOW
    { (Color){ 128, 128, 128, 255 }, 0, "Bridge" } // TILE_COLOR_BRIDGE
  };

  if (color >= 0 && color < TILE_COLOR_COUNT)
    {
      return colorInfos[color];
    }

  // Return default if invalid color
  return (TileColorInfo){ LIGHTGRAY, 0, "Unknown" };
}

void
GameState_DrawDots (Vector2 center, float radius, int dotCount, Color dotColor)
{
  float dotRadius = radius * 0.12f;

  if (dotCount == 1)
    {
      // Single dot in center
      DrawCircleV (center, dotRadius, dotColor);
    }
  else if (dotCount == 2)
    {
      // Two dots horizontally
      float spacing = radius * 0.25f;
      DrawCircleV ((Vector2){ center.x - spacing, center.y }, dotRadius,
                   dotColor);
      DrawCircleV ((Vector2){ center.x + spacing, center.y }, dotRadius,
                   dotColor);
    }
  else if (dotCount == 3)
    {
      // Three dots in triangle formation
      float spacing = radius * 0.2f;
      DrawCircleV ((Vector2){ center.x, center.y - spacing }, dotRadius,
                   dotColor);
      DrawCircleV ((Vector2){ center.x - spacing, center.y + spacing },
                   dotRadius, dotColor);
      DrawCircleV ((Vector2){ center.x + spacing, center.y + spacing },
                   dotRadius, dotColor);
    }
}
